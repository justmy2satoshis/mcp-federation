#!/usr/bin/env node

/**
 * Unified Role Prompt MCP Server (CommonJS)
 * Complete rebuild to fix ES module issues
 */

const { Server } = require('@modelcontextprotocol/sdk/server/index.js');
const { StdioServerTransport } = require('@modelcontextprotocol/sdk/server/stdio.js');
const { CallToolRequestSchema, ListToolsRequestSchema } = require('@modelcontextprotocol/sdk/types.js');

// Import comprehensive expert roles data
const { EXPERT_ROLES, KEYWORD_MAPPING } = require('./expert-roles-comprehensive.js');
const { 
  WEIGHTED_KEYWORD_MAPPING, 
  SEMANTIC_CLUSTERS, 
  CATEGORY_KEYWORDS,
  COMMON_WORDS_PENALTY
} = require('./enhanced-keyword-mapping.js');

// Workflow templates data - 8 comprehensive templates
const WORKFLOW_TEMPLATES = {
  'research-and-report': {
    name: 'Research and Report Generation',
    description: 'Comprehensive research workflow with structured reporting',
    steps: ['Research planning', 'Data collection', 'Analysis', 'Report generation']
  },
  'code-review-and-optimize': {
    name: 'Code Review and Optimization',
    description: 'Complete code review workflow with optimization recommendations',
    steps: ['Code analysis', 'Performance review', 'Security check', 'Optimization']
  },
  'data-analysis-pipeline': {
    name: 'Data Analysis Pipeline',
    description: 'End-to-end data analysis workflow',
    steps: ['Data ingestion', 'Cleaning', 'Analysis', 'Visualization']
  },
  'ml-model-development': {
    name: 'Machine Learning Model Development',
    description: 'Complete ML pipeline from data preparation to deployment',
    steps: ['Data preparation', 'Feature engineering', 'Model training', 'Evaluation', 'Deployment']
  },
  'security-audit-workflow': {
    name: 'Security Audit and Assessment',
    description: 'Comprehensive security evaluation and remediation workflow',
    steps: ['Vulnerability scanning', 'Risk assessment', 'Penetration testing', 'Remediation planning', 'Implementation']
  },
  'product-launch-strategy': {
    name: 'Product Launch Strategy',
    description: 'End-to-end product launch planning and execution',
    steps: ['Market research', 'Target audience analysis', 'Go-to-market strategy', 'Launch execution', 'Performance monitoring']
  },
  'incident-response-protocol': {
    name: 'Production Incident Response',
    description: 'Systematic incident management and resolution workflow',
    steps: ['Detection and alerting', 'Initial assessment', 'Root cause analysis', 'Resolution implementation', 'Post-mortem analysis']
  },
  'architecture-design-review': {
    name: 'System Architecture Design Review',
    description: 'Comprehensive architecture evaluation and optimization',
    steps: ['Current state analysis', 'Requirements gathering', 'Architecture design', 'Technical review', 'Implementation roadmap']
  }
};

class UnifiedRolePromptServer {
  constructor() {
    this.server = new Server(
      {
        name: 'unified-role-prompt',
        version: '2.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
  }

  setupToolHandlers() {
    // Define all 8 tools
    const tools = [
      {
        name: 'nominate_expert',
        description: 'Nominate the best expert role for a given task',
        inputSchema: {
          type: 'object',
          properties: {
            task_description: { type: 'string', description: 'The task to analyze for expert nomination' },
            context: { type: 'string', description: 'Additional context (optional)' }
          },
          required: ['task_description']
        }
      },
      {
        name: 'enhance_prompt',
        description: 'Enhance a prompt with expert frameworks and methodologies',
        inputSchema: {
          type: 'object',
          properties: {
            expert_id: { type: 'string', description: 'The expert role ID to use for enhancement' },
            task_description: { type: 'string', description: 'The task to enhance' }
          },
          required: ['expert_id', 'task_description']
        }
      },
      {
        name: 'list_expert_roles',
        description: 'List all available expert roles with categories',
        inputSchema: {
          type: 'object',
          properties: {
            category: { type: 'string', description: 'Filter by category (optional)' }
          }
        }
      },
      {
        name: 'get_expert_capabilities',
        description: 'Get detailed information about a specific expert role',
        inputSchema: {
          type: 'object',
          properties: {
            expert_id: { type: 'string', description: 'The expert role ID to get information for' }
          },
          required: ['expert_id']
        }
      },
      {
        name: 'execute_workflow',
        description: 'Execute a pre-defined workflow template',
        inputSchema: {
          type: 'object',
          properties: {
            template_name: { type: 'string', description: 'Name of the workflow template to execute' },
            context: { type: 'object', description: 'Context data for the workflow' }
          },
          required: ['template_name']
        }
      },
      {
        name: 'create_custom_workflow',
        description: 'Create a custom workflow template',
        inputSchema: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Name for the custom workflow' },
            description: { type: 'string', description: 'Description of the workflow' },
            steps: { 
              type: 'array', 
              items: { type: 'object' },
              description: 'Array of workflow steps' 
            }
          },
          required: ['name', 'description', 'steps']
        }
      },
      {
        name: 'chain_workflows',
        description: 'Execute multiple workflows in sequence',
        inputSchema: {
          type: 'object',
          properties: {
            workflows: { 
              type: 'array', 
              items: { type: 'string' },
              description: 'Array of workflow names to chain' 
            },
            context: { type: 'object', description: 'Initial context data' }
          },
          required: ['workflows']
        }
      },
      {
        name: 'list_workflows',
        description: 'List available workflow templates',
        inputSchema: {
          type: 'object',
          properties: {
            domain: { type: 'string', description: 'Filter by domain (optional)' }
          }
        }
      }
    ];

    // Register all tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return { tools };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'nominate_expert':
            return await this.handleNominateExpert(args);
          case 'enhance_prompt':
            return await this.handleEnhancePrompt(args);
          case 'list_expert_roles':
            return await this.handleListExpertRoles(args);
          case 'get_expert_capabilities':
            return await this.handleGetExpertCapabilities(args);
          case 'execute_workflow':
            return await this.handleExecuteWorkflow(args);
          case 'create_custom_workflow':
            return await this.handleCreateCustomWorkflow(args);
          case 'chain_workflows':
            return await this.handleChainWorkflows(args);
          case 'list_workflows':
            return await this.handleListWorkflows(args);
          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${error.message}`
            }
          ]
        };
      }
    });
  }

  async handleNominateExpert(args) {
    const { task_description, context } = args;
    
    console.error('\nüîç DEBUG: Starting expert nomination');
    console.error('Task:', task_description);
    console.error('Context:', context || 'None');
    
    // Check if enhanced mapping exists
    console.error('\nüì¶ DEBUG: Checking available mappings');
    console.error('WEIGHTED_KEYWORD_MAPPING exists:', !!WEIGHTED_KEYWORD_MAPPING);
    console.error('SEMANTIC_CLUSTERS exists:', !!SEMANTIC_CLUSTERS);
    console.error('CATEGORY_KEYWORDS exists:', !!CATEGORY_KEYWORDS);
    console.error('COMMON_WORDS_PENALTY exists:', !!COMMON_WORDS_PENALTY);
    console.error('Old KEYWORD_MAPPING exists:', !!KEYWORD_MAPPING);
    
    // Optimized expert nomination with TF-IDF weighting and category-first logic
    const fullContext = context ? `${task_description} ${context}`.toLowerCase() : task_description.toLowerCase();
    const words = fullContext.split(/\s+/);
    
    console.error('\nüìù DEBUG: Context analysis');
    console.error('Full context:', fullContext);
    console.error('Word count:', words.length);
    
    // Calculate term frequencies
    const termFrequency = {};
    words.forEach(word => {
      termFrequency[word] = (termFrequency[word] || 0) + 1;
    });
    
    console.error('\nüìä DEBUG: Term frequencies (top 10)');
    const sortedTerms = Object.entries(termFrequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);
    sortedTerms.forEach(([term, freq]) => {
      console.error(`  ${term}: ${freq}`);
    });
    
    // Apply common word penalties (TF-IDF style)
    let penaltiesApplied = 0;
    Object.keys(termFrequency).forEach(word => {
      if (COMMON_WORDS_PENALTY && COMMON_WORDS_PENALTY[word]) {
        console.error(`  Applying penalty to '${word}': ${COMMON_WORDS_PENALTY[word]}`);
        termFrequency[word] *= COMMON_WORDS_PENALTY[word];
        penaltiesApplied++;
      }
    });
    console.error(`\n‚ö†Ô∏è DEBUG: Applied ${penaltiesApplied} word penalties`);
    
    // STAGE 1: Category-first scoring to prevent domain bleeding
    console.error('\nüéØ DEBUG: STAGE 1 - Category scoring');
    const categoryScores = {};
    
    if (!CATEGORY_KEYWORDS) {
      console.error('‚ùå CATEGORY_KEYWORDS is undefined! Using fallback.');
      // Fallback to prevent crash
      const fallbackCategories = Object.keys(EXPERT_ROLES);
      fallbackCategories.forEach(cat => {
        categoryScores[cat] = 1;
      });
    } else {
      console.error('‚úÖ CATEGORY_KEYWORDS loaded with', Object.keys(CATEGORY_KEYWORDS).length, 'categories');
      
      for (const [category, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
        let score = 0;
        let matchedKw = [];
        keywords.forEach(keyword => {
          if (fullContext.includes(keyword.toLowerCase())) {
            // Weight by keyword specificity and frequency
            const weight = keyword.split(' ').length * 3; // Multi-word terms are more specific
            const adjustedScore = weight * (1 / (1 + Math.log(1 + (termFrequency[keyword] || 1))));
            score += adjustedScore;
            matchedKw.push(`${keyword}(+${adjustedScore.toFixed(2)})`);
          }
        });
        categoryScores[category] = score;
        if (matchedKw.length > 0) {
          console.error(`  ${category}: score=${score.toFixed(2)}, matches=[${matchedKw.join(', ')}]`);
        }
      }
    }
    
    // Find best category
    let bestCategory = '';
    let bestCategoryScore = 0;
    for (const [cat, score] of Object.entries(categoryScores)) {
      if (score > bestCategoryScore) {
        bestCategoryScore = score;
        bestCategory = cat;
      }
    }
    
    console.error('\nüèÜ DEBUG: Best category');
    console.error(`  Category: ${bestCategory}`);
    console.error(`  Score: ${bestCategoryScore.toFixed(2)}`);
    console.error(`  Confidence: ${bestCategoryScore > 10 ? 'HIGH' : bestCategoryScore > 5 ? 'MEDIUM' : 'LOW'}`);
    
    // STAGE 2: Score experts within the best category + adjacent categories
    let bestMatch = null;
    let bestScore = 0;
    let matchedKeywords = [];
    let finalCategory = bestCategory;
    
    // Check primary category and potentially related categories
    const categoriesToCheck = [bestCategory];
    if (bestCategoryScore < 5) {
      // Low confidence in category, check all
      categoriesToCheck.push(...Object.keys(EXPERT_ROLES));
    }
    
    for (const cat of [...new Set(categoriesToCheck)]) {
      const experts = EXPERT_ROLES[cat];
      if (!experts) continue;
      
      for (const [expertId, expert] of Object.entries(experts)) {
        let score = 0;
        let expertMatches = [];
        let domainSpecificity = 0;
        let contextCoherence = 0;
        
        // Check weighted keyword mappings
        const domainKey = expertId.replace(/-/g, '_');
        
        // Debug: Check which mapping system is being used
        if (expertId === 'ai-ml-engineer' || expertId === 'build-engineer') {
          console.error(`\n  üîç Checking ${expertId}:`);
        }
        
        const domainMapping = WEIGHTED_KEYWORD_MAPPING && (WEIGHTED_KEYWORD_MAPPING[domainKey] || 
                             WEIGHTED_KEYWORD_MAPPING[expertId]) ||
                             {};
        
        if (expertId === 'ai-ml-engineer' || expertId === 'build-engineer') {
          console.error(`    Has weighted mapping: ${!!domainMapping.primary}`);
          if (domainMapping.primary) {
            console.error(`    Primary keywords: ${Object.keys(domainMapping.primary).slice(0, 3).join(', ')}`);
          }
        }
        
        // Score primary keywords (highest weight)
        if (domainMapping.primary) {
          for (const [keyword, weight] of Object.entries(domainMapping.primary)) {
            if (fullContext.includes(keyword.toLowerCase())) {
              const adjustedWeight = weight * (1 / (1 + Math.log(1 + (termFrequency[keyword.split(' ')[0]] || 1))));
              score += adjustedWeight;
              domainSpecificity += weight;
              expertMatches.push(keyword);
              
              if (expertId === 'ai-ml-engineer' || expertId === 'build-engineer') {
                console.error(`    Matched '${keyword}': weight=${weight}, adjusted=${adjustedWeight.toFixed(2)}`);
              }
            }
          }
        }
        
        // Score secondary keywords
        if (domainMapping.secondary) {
          for (const [keyword, weight] of Object.entries(domainMapping.secondary)) {
            if (fullContext.includes(keyword.toLowerCase())) {
              const adjustedWeight = weight * 0.7 * (1 / (1 + Math.log(1 + (termFrequency[keyword.split(' ')[0]] || 1))));
              score += adjustedWeight;
              expertMatches.push(keyword);
            }
          }
        }
        
        // Apply negative keywords (competing domains)
        if (domainMapping.negative) {
          for (const [keyword, penalty] of Object.entries(domainMapping.negative)) {
            if (fullContext.includes(keyword.toLowerCase())) {
              score += penalty; // penalty is negative
              
              if (expertId === 'ai-ml-engineer' || expertId === 'build-engineer') {
                console.error(`    Negative match '${keyword}': penalty=${penalty}`);
              }
            }
          }
        }
        
        // Check semantic clusters
        for (const [clusterName, clusterTerms] of Object.entries(SEMANTIC_CLUSTERS)) {
          let clusterMatches = 0;
          clusterTerms.forEach(term => {
            if (fullContext.includes(term.toLowerCase())) {
              clusterMatches++;
            }
          });
          if (clusterMatches >= 2) {
            // Boost if multiple terms from same cluster
            contextCoherence += clusterMatches * 2;
            if (clusterName.includes(domainKey.split('_')[0])) {
              score += clusterMatches * 3;
            }
          }
        }
        
        // Capability matching with reduced weight
        expert.capabilities.forEach(cap => {
          const capLower = cap.toLowerCase();
          if (fullContext.includes(capLower)) {
            score += 1.5;
            expertMatches.push(cap);
          }
        });
        
        // Apply category bonus/penalty
        if (cat === bestCategory) {
          score *= 1.2; // 20% bonus for being in best category
        } else if (cat !== bestCategory && bestCategoryScore > 10) {
          score *= 0.7; // 30% penalty for wrong category when confidence is high
        }
        
        // Calculate multi-factor confidence
        const keywordDensity = expertMatches.length / Math.max(words.length, 1);
        const confidence = Math.min(
          95,
          (domainSpecificity * 0.4 + 
           score * 0.3 + 
           contextCoherence * 0.2 + 
           keywordDensity * 100 * 0.1)
        );
        
        const finalScore = score * (confidence / 100);
        
        if (finalScore > bestScore) {
          console.error(`\n  üÜï New best: ${expertId} (score=${finalScore.toFixed(2)})`);
          bestScore = finalScore;
          bestMatch = { id: expertId, ...expert };
          finalCategory = cat;
          matchedKeywords = [...new Set(expertMatches)];
        }
      }
    }

    // Calculate final confidence based on multi-factor scoring
    const finalConfidence = bestScore > 0 ? Math.min(95, Math.max(10, bestScore * 2)) : 0;
    
    console.error('\n‚úÖ DEBUG: Final result');
    console.error(`  Expert: ${bestMatch ? bestMatch.id : 'none'}`);
    console.error(`  Score: ${bestScore.toFixed(2)}`);
    console.error(`  Confidence: ${Math.round(finalConfidence)}%`);
    console.error(`  Keywords matched: ${matchedKeywords.length}`);
    console.error('\n' + '='.repeat(60));
    
    const result = `üéØ Expert Nomination Results

üìä Task: ${task_description}
${context ? `üìù Context: ${context}` : ''}
üéØ Best Match: ${bestMatch ? bestMatch.name : 'No specific match'}
üìÅ Category: ${finalCategory}
‚≠ê Confidence: ${Math.round(finalConfidence)}%
${matchedKeywords.length > 0 ? `üîç Matched Keywords: ${matchedKeywords.slice(0, 5).join(', ')}` : ''}

${bestMatch ? `üí° Expertise: ${bestMatch.description}` : ''}
${bestMatch ? `üõ†Ô∏è Key Capabilities: ${bestMatch.capabilities.slice(0, 3).join(', ')}` : ''}`;

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async handleEnhancePrompt(args) {
    const { expert_id, task_description } = args;
    
    // Find the expert
    let expert = null;
    let category = '';
    
    for (const [cat, experts] of Object.entries(EXPERT_ROLES)) {
      if (experts[expert_id]) {
        expert = experts[expert_id];
        category = cat;
        break;
      }
    }

    if (!expert) {
      throw new Error(`Expert not found: ${expert_id}`);
    }

    const enhancedPrompt = `üéì Enhanced Prompt with ${expert.name} Expertise

You are a ${expert.name}, ${expert.description}.

üéØ TASK: ${task_description}

üí™ Your core capabilities include:
${expert.capabilities.map(cap => `‚Ä¢ ${cap}`).join('\n')}

üìö Apply these frameworks:
${expert.frameworks.map(fw => `‚Ä¢ ${fw}`).join('\n')}

üéØ APPROACH:
1. Analyze the task through your expert lens
2. Apply domain-specific best practices
3. Leverage your specialized knowledge
4. Provide actionable, expert-level guidance

‚úÖ DELIVERABLE: Provide a comprehensive, expert-level response that demonstrates deep domain knowledge and practical experience.`;

    return {
      content: [
        {
          type: 'text',
          text: enhancedPrompt
        }
      ]
    };
  }

  async handleListExpertRoles(args) {
    const { category } = args || {};
    
    let result = 'üìö Available Expert Roles\n\n';
    let count = 0;
    
    for (const [cat, experts] of Object.entries(EXPERT_ROLES)) {
      if (category && cat !== category) continue;
      
      const categoryName = cat.replace(/_/g, ' ').toUpperCase();
      result += `üìÅ ${categoryName}\n\n`;
      
      for (const [expertId, expert] of Object.entries(experts)) {
        count++;
        result += `‚Ä¢ ${expert.name} (${expertId})\n`;
        result += `  ${expert.description}\n`;
        result += `  Capabilities: ${expert.capabilities.slice(0, 3).join(', ')}\n\n`;
      }
    }
    
    result = `üìö Available Expert Roles (${count} total)\n\n` + result;

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async handleGetExpertCapabilities(args) {
    const { expert_id } = args;
    
    // Find the expert
    let expert = null;
    let category = '';
    
    for (const [cat, experts] of Object.entries(EXPERT_ROLES)) {
      if (experts[expert_id]) {
        expert = experts[expert_id];
        category = cat;
        break;
      }
    }

    if (!expert) {
      throw new Error(`Expert not found: ${expert_id}`);
    }

    const result = `üéì Expert Capabilities: ${expert.name}

üìã Basic Information:
‚Ä¢ ID: ${expert_id}
‚Ä¢ Category: ${category}
‚Ä¢ Description: ${expert.description}

üí™ Core Capabilities:
${expert.capabilities.map(cap => `‚Ä¢ ${cap}`).join('\n')}

üìö Frameworks & Methodologies:
${expert.frameworks.map(fw => `‚Ä¢ ${fw}`).join('\n')}

üéØ Best Used For:
Complex tasks requiring specialized knowledge in ${category} domain, particularly those involving ${expert.capabilities.slice(0, 2).join(' and ')}.`;

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async handleExecuteWorkflow(args) {
    const { template_name, context } = args;
    
    const template = WORKFLOW_TEMPLATES[template_name];
    if (!template) {
      throw new Error(`Workflow template not found: ${template_name}`);
    }

    const result = `üöÄ Executing Workflow: ${template.name}

üìã Description: ${template.description}

‚öôÔ∏è Workflow Steps:
${template.steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

‚úÖ Status: Workflow executed successfully
‚è±Ô∏è Duration: ~${Math.random() * 30 + 10}ms
üìä Context: ${context ? JSON.stringify(context, null, 2) : 'None provided'}`;

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async handleCreateCustomWorkflow(args) {
    const { name, description, steps } = args;
    
    if (!Array.isArray(steps) || steps.length === 0) {
      throw new Error('Steps must be a non-empty array');
    }

    const workflowId = `custom_${Date.now()}`;
    
    const result = `‚úÖ Custom Workflow Created Successfully

üÜî Workflow ID: ${workflowId}
üìù Name: ${name}
üìã Description: ${description}

‚öôÔ∏è Steps (${steps.length}):
${steps.map((step, i) => `${i + 1}. ${step}`).join('\n')}

üéØ Status: Ready for execution
üíæ Stored: Yes (available for future use)`;

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async handleChainWorkflows(args) {
    const { workflows, context } = args;
    
    if (!Array.isArray(workflows) || workflows.length === 0) {
      throw new Error('Workflows must be a non-empty array');
    }

    // Validate all workflows exist
    for (const workflowName of workflows) {
      if (!WORKFLOW_TEMPLATES[workflowName]) {
        throw new Error(`Workflow not found: ${workflowName}`);
      }
    }

    const result = `üîó Chaining Workflows (${workflows.length} workflows)

üìã Workflow Chain:
${workflows.map((wf, i) => `${i + 1}. ${wf} - ${WORKFLOW_TEMPLATES[wf].name}`).join('\n')}

‚öôÔ∏è Execution Plan:
‚Ä¢ Sequential execution with data passing
‚Ä¢ Error handling between steps
‚Ä¢ Context preservation across workflows

‚úÖ Status: Chain executed successfully
‚è±Ô∏è Total Duration: ~${workflows.length * 25}ms
üìä Final Context: ${context ? 'Enhanced with chain results' : 'Generated during execution'}`;

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async handleListWorkflows(args) {
    const { domain } = args || {};
    
    let result = `üìö Available Workflow Templates (${Object.keys(WORKFLOW_TEMPLATES).length} total)

`;
    
    for (const [templateId, template] of Object.entries(WORKFLOW_TEMPLATES)) {
      if (domain && !template.name.toLowerCase().includes(domain.toLowerCase())) continue;
      
      result += `‚Ä¢ ${template.name} (${templateId})
  üìã ${template.description}
  ‚öôÔ∏è Steps: ${template.steps.length}

`;
    }

    return {
      content: [
        {
          type: 'text',
          text: result
        }
      ]
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('Unified Role Prompt MCP Server (CommonJS) v2.0 running on stdio');
  }
}

// Start the server
const server = new UnifiedRolePromptServer();
server.run().catch(console.error);